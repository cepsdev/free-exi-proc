exegesis{
built_in_data_type_representations{
 unsigned_int{
  decode{
    uint64{
     interface{ 
       args{
        buffer{ARG0;};
       };
       ev{
        kind Event;
        Event DecodeVarUIntToUint64;
        DecodeVarUIntToUint64;
       };
      };
    };
  };
 };
};
};

exegesis{
built_in_data_type_representations{
 unsigned_int{
  decode{
    uint64{
     impl_inline{
     oblectamenta{text{asm{
      //Multiple 'tricks' used here to make the code more readable.
      // 1. Code parts are pulled from different locations via document path expressions, i.e. expressions of the form root.A.B...
      // 2. values defined via val are actually evaluated during compile time 
      // 3. values can be symbols, this allows us to rename registers with a telling name, e.g. val input = R5 allows us to use 'input' everywhere where R5 is allowed.
     val input_buffer = root.exegesis.built_in_data_type_representations.unsigned_int.decode.uint64.interface.args.buffer.content();
     OblectamentaCodeLabel loop;
     OblectamentaCodeLabel loop_exit;

     val value = RES; // Decoded value is stored in RES. 
     val multiplier_lg = R2; // Multiplier resides in R2.
     val encoded_value_addr = input_buffer;
     val encoded_value_idx = R4;
     val encoded_value_current_byte = R5;
     
     ldi64(0);       
     sti64(value);          // value = 0   
     ldi64(0);
     sti64(multiplier_lg); // multiplier = lg(1) = 0 (we shift)
     invariant{value == 0; multiplier_lg == 0; bitwidth(value) == 64;};
     ldi64(0);
     sti64(encoded_value_idx);
    loop;
     ldi64(encoded_value_addr);
     ldi64(encoded_value_idx);
     addi64;
     ldsi8;
     ui8toui64;
     ldi64(127);
     andi64;
     sti64(encoded_value_current_byte); //encoded_value_current_byte = encoded_value_addr[encoded_value_idx]
     ldi32(multiplier_lg);
     ldi64(encoded_value_current_byte);
     shli64;
     ldi64(value);
     addi64;
     sti64(value);
     ldi32(128);
     ldi64(encoded_value_addr);
     ldi64(encoded_value_idx);
     addi64;
     ldsi8;
     ui8toui32;
     blt(loop_exit);
     ldi64(encoded_value_idx);
     ldi64(1);
     addi64;
     sti64(encoded_value_idx);
     ldi32(multiplier_lg);
     ldi32(7);
     addi32;
     sti32(multiplier_lg);
     buc(loop);
    loop_exit;
     dbg_print_cs_and_regs(0);
    };};};

     };//impl_inline
   };
 };
};
};
};

exegesis{

OblectamentaDataLabel input_unsigned_int_0;
OblectamentaDataLabel input_unsigned_int_1;
OblectamentaDataLabel input_unsigned_int_128, input_unsigned_int_256, input_unsigned_int_16384, input_unsigned_int_2097152;

oblectamenta{
 global{
  data{
    1;
    input_unsigned_int_0;
    as_uint8(0);           // |000000000|
    input_unsigned_int_1;
    as_uint8(1);           // |000000001|
    input_unsigned_int_128;
    as_uint8(128);
    as_uint8(1);           // |100000000|00000001|
    input_unsigned_int_256;
    as_uint8(128);
    as_uint8(2);           // |100000000|00000010|
    input_unsigned_int_16384;
    as_uint8(128);
    as_uint8(128);
    as_uint8(1);           // |100000000|100000000|00000001|
    input_unsigned_int_2097152;
    as_uint8(128);
    as_uint8(128);
    as_uint8(128);
    as_uint8(1);           // |100000000|100000000|100000000|00000001|
  };
 };
};


sm{
 DecodeUnsignedIntegerui64;
 states{Initial;Decode;};
 Actions{
  doDecode{
   OblectamentaDataLabel  input_unsigned_int_2097152;
   val input = input_unsigned_int_2097152;
   oblectamenta{text{asm{
    lea(input);
    sti64(root.exegesis.built_in_data_type_representations.unsigned_int.decode.uint64.interface.args.buffer.content());
    root.exegesis.built_in_data_type_representations.unsigned_int.decode.uint64.impl_inline.oblectamenta.text.asm.content();
   };};};
  };
 };
 t{Initial;Decode;root.exegesis.built_in_data_type_representations.unsigned_int.decode.uint64.interface.ev.content();doDecode;};
};// sm EncodeUnsignedInteger

sm{
  TestDecoder;
  Actions{
   doTest1{
    oblectaments{text{asm{};};};
   };
  };
  states{Initial;Final;};
  t{Initial;Final;doTest1;};
};

};