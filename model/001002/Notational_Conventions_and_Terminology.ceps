label __1__2 title = "1.2 Notational Conventions and Terminology";
kind DocgenStringPrintNoEscape;
DocgenStringPrintNoEscape docinfo_se;

witness{
docinfo_se(

"
1.
The key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED,
MAY, and OPTIONAL, when they appear EMPHASIZED in this document, are to be interpreted as
described in RFC 2119. Other terminology used to describe the EXI format is defined in the body of this specification.

The term evenbt and stream is used throughout this document to denote EXI event and EXI stream
respectively unless the words are qualified differently to mean otherwise.

thsi document specifies an abstract grammar for EXI. In grammar notation, all terminal symbols
are representes in plain text and all non-terminal symbols are represented in italics. Grammar
productions are represented as follows:

LeftHandSide: Terminal NonTerminal

A set of one or more grammar productions that share the same left-hand side non-terminal
symbol are often presented together annotated with event codes that specify how events
matching the terminal symbols of the associated productions are represented in the EXI
stream as follows:

LeftHandSide:
 Terminal_1 NonTerminal_1    EventCode_1
 Terminal_2 NonTerminal_2    EventCode_2
 Terminal_3 NonTerminal_3    EventCode_3

 ...

 Terminal_n NonTerminal_n    EventCode_n 

Section 8.1 Grammar Notation introduces additional notations for describing productions
and event codes in grammars. Those additional notations facilitate concise representation
of the EXI grammar system.

[Definition:] In this document, the term qname is used to denot a QName. QName values are 
composed of an uri, a local-name and an optional prefix. Two qnames are considered equal
if they have the same uri and local-name, regardless of their prefix values. In cases where
prefixes are not relevant, such as in the grammar notation, they are not specified by this
document.

Terminal symbols that are qualified with a qnmae permit the use of a wildcard symbol (*) in
place of or as part of a qname. The forms of terminal symbols involving qname wildcards
used in grammars and their definitions are described in the table below.

Wildcard                              Definition


SE(*)                                 The terminal symbol that matches a start element (SE)
                                      event with any qname.
SE(uri: *)                            The terminal symbol that matches a start element (SE)
                                      event with any local-name in namespace uri.
AT(*)                                 The terminal symbol that matches an attribute (AT)
                                      event with any qname
AT (uri:*)                            The terminal symbol that matches an attribute (AT)
                                      event with any local-name in namespace uri.

Several prefixes are used throughout this document to designate certain namespaces.
The bindings shown below are assumed, however, any prefixes can be used in practice if
they are properly bound to the namespaces.

Prefix                               Namespace Name
exi                                  http://www.w3.org/2009/exi
xsd                                  http://www.w3.org/2001/XMLSchema
xsi                                  http://www.w3.org/2001/XMLSchema-instance

In describing the layout of an EXI format construct, a pair of square brackets [] are
used to surround the name of a field to denote that the occurrence of the field is optional
in the structure of the part or component that contains the field.

In arithmetic expressions, the notation ceil(x) where x represents a real number denotes the 
ceiling of x, that is, the smallest integer greater than or equal to x.

When it is stated that strings are sorted in lexicographical order, it is done so character
by character, and the order among characters is determines by comparing their Unicode
code points.

Unless stated otherwise, when this specification indicates one type is derived form another
type, it means the type is derived by extension or restriction, not by union or list. 
Similarly, when this specification uses the term type hierarchy, it is referring to the
hierarchy of types derived from another by extension or restriction.
"

);
};

propaedeutics{


};    

kind GrammarNonterminal;
kind GrammarTerminal;
kind GrammarAnnotation;

example{
    label __1__2_grammar title="EXI knows Right Regular grammars only";
    GrammarNonterminal LeftHandSide;
    GrammarNonterminal NonTerminal_1;
    GrammarNonterminal NonTerminal_2;
    GrammarNonterminal NonTerminal_3;
    GrammarNonterminal NonTerminal_n;

    GrammarTerminal Terminal_1;
    GrammarTerminal Terminal_2;
    GrammarTerminal Terminal_3;
    GrammarTerminal Terminal_n;
    GrammarAnnotation EventCode;

    Grammar{
            lhs{NonTerminal_1;};
                rhs{Terminal_1; NonTerminal_1;EventCode(1); };
                rhs{Terminal_2; NonTerminal_2;EventCode(2); };
                rhs{Terminal_3; NonTerminal_3;EventCode(3); };
                rhs{Terminal_n; NonTerminal_n;EventCode(n); };          
    };
};

kind EXIConcept_Grammar_EachLHSContainsExactlyOneNonTerminal;
kind EXIConcept_Grammar_NoDanglingLHS;

EXIConcept_Grammar_EachLHSContainsExactlyOneNonTerminal 
 EachLHSContainsExactlyOneNonTerminal;
EXIConcept_Grammar_NoDanglingLHS NoDanglingLHS;


label __1__2__CheckEXIConcept_Grammar_EachLHSContainsExactlyOneNonTerminal 
 title = "Concept: Grammar_EachLHSContainsExactlyOneNonTerminal";

macro CheckEXIConcept_Grammar_EachLHSContainsExactlyOneNonTerminal
{
    val violation = 0;
    for(e : arglist.Grammar.rhs){
        if (e.contains_symbol("GrammarNonterminal").size() == 0) {
            let violation = 1;
        }
    }
    !violation;
};
label __1__2__CheckEXIConcept_Grammar_EachLHSContainsExactlyOneNonTerminal_ex1 
 title = "Example 1 (Grammar_EachLHSContainsExactlyOneNonTerminal)";
docinfo_se(

"Example of a grammar not satisfying EXIConcept_Grammar_EachLHSContainsExactlyOneNonTerminal.
"

);

Grammar{
    lhs{LeftHandSide;};
        rhs{ Terminal_1;};
};

CheckEXIConcept_Grammar_EachLHSContainsExactlyOneNonTerminal{
    GrammarNonterminal LeftHandSide;
    GrammarNonterminal NonTerminal_1;
    GrammarNonterminal NonTerminal_2;
    GrammarNonterminal NonTerminal_3;
    GrammarNonterminal NonTerminal_n;

    GrammarTerminal Terminal_1;
    GrammarTerminal Terminal_2;
    GrammarTerminal Terminal_3;
    GrammarTerminal Terminal_n;
    GrammarAnnotation EventCode;

    Grammar{
        lhs{LeftHandSide;};
         rhs{Terminal_1;};
    };
};